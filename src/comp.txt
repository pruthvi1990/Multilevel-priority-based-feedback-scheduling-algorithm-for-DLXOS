//							      <
//	process.c					      <
//							      <
//	This file defines routines for dealing with processes <
//	includes the "main" routine for the OS, which creates <
//	for the initial thread of execution.  It also include <
//	code to create and delete processes, as well as conte <
//	code.  Note, however, that the actual context switchi <
//	done in assembly language elsewhere.		      <
//	DJ is great.. Teammates: Dhiraj & Pruthvi	      <
							      <
#include "dlxos.h"						#include "dlxos.h"
#include "process.h"						#include "process.h"
//#include "synch.h"						//#include "synch.h"
#include "memory.h"						#include "memory.h"
#include "filesys.h"						#include "filesys.h"
float MyFuncRetZero();						float MyFuncRetZero();

							      >
// Lab3: These two string are defined for you to print out yo	// Lab3: These two string are defined for you to print out yo
// timming analysis.  Do not use your own strings.		// timming analysis.  Do not use your own strings.
// Your printf statement should be printf(TIMESTRING1,data1..	// Your printf statement should be printf(TIMESTRING1,data1..
// note that we need to print the floating point value by its	// note that we need to print the floating point value by its
// otherwise it is not going to print right			// otherwise it is not going to print right

							      >
#define TIMESTRING1  "Process %d has run for"			#define TIMESTRING1  "Process %d has run for"
#define TIMESTRING2  " %.3f s\n"				#define TIMESTRING2  " %.3f s\n"
#define TIMESTRING3  "Process %d 's priority is %d \n"	      |	#define TIMESTRING3  "Process %d 's priority is %d\n"
							      >
							      >
							      >	#define TOTAL_QUANTA_MAX 10
							      >	#define PROCESS_QUANTA_MAX 4
							      >
							      >
							      >	#define TRUE 1
							      >	#define FALSE 0
							      >

// Pointer to the current PCB.  This is used by the assembly 	// Pointer to the current PCB.  This is used by the assembly 
// routines for context switches.				// routines for context switches.
PCB		*currentPCB;					PCB		*currentPCB;

							      >
// List of free PCBs.						// List of free PCBs.
static Queue	freepcbs;					static Queue	freepcbs;

							      >
// List of processes that are ready to run (ie, not waiting f	// List of processes that are ready to run (ie, not waiting f
// to happen).							// to happen).
static Queue	runQueue[32];					static Queue	runQueue[32];

							      >
// List of processes that are waiting for something to happen	// List of processes that are waiting for something to happen
// reason why this must be a single list; there could be many	// reason why this must be a single list; there could be many
// different conditions.					// different conditions.
static Queue	waitQueue;					static Queue	waitQueue;

							      >
// List of processes waiting to be deleted.  See below for a 	// List of processes waiting to be deleted.  See below for a 
// the reason that we need a separate queue for processes abo	// the reason that we need a separate queue for processes abo
static Queue	zombieQueue;					static Queue	zombieQueue;

							      >
// Static area for all process control blocks.  This is neces	// Static area for all process control blocks.  This is neces
// we can't use malloc() inside the OS.				// we can't use malloc() inside the OS.
static PCB	pcbs[PROCESS_MAX_PROCS];			static PCB	pcbs[PROCESS_MAX_PROCS];

							      >
// Default value for scheduler quantum.  This could be set to	// Default value for scheduler quantum.  This could be set to
// In fact, it could even be dynamic, though that would requi	// In fact, it could even be dynamic, though that would requi
// the timer trap handler....					// the timer trap handler....
static processQuantum = DLX_PROCESS_QUANTUM;			static processQuantum = DLX_PROCESS_QUANTUM;
int x;							      |
							      >
// String listing debugging options to print out.		// String listing debugging options to print out.
char	debugstr[200];						char	debugstr[200];
static uint32 Track10Quanta = 0;			      |
static int processStartTime = 0;			      |
int numOfProcessesInRunQueue = 0;			      |	static uint32 totalQuanta = 0;
int temp1;						      |	static uint32 startTime = 0;
int temp2;						      |
//Dhiraj Chaudhary//					      |
//Function taken from bugs file				      |	uint32 my_timer_get() {
uint32 my_timer_get(){					      |	  return totalQuanta * 100 + totalQuanta;
uint32 temp = Track10Quanta * 100 + Track10Quanta * 1;	      <
return temp;						      <
}								}


//-----------------------------------------------------------	//-----------------------------------------------------------
//								//
//	ProcessModuleInit					//	ProcessModuleInit
//								//
//	Initialize the process module.  This involves initial	//	Initialize the process module.  This involves initial
//	of the process control blocks to appropriate values (	//	of the process control blocks to appropriate values (
//	and available).  We also need to initialize all of th	//	and available).  We also need to initialize all of th
//								//
//-----------------------------------------------------------	//-----------------------------------------------------------
void							      |	  void
ProcessModuleInit ()						ProcessModuleInit ()
{								{
  int		i;						  int		i;

							      >
  dbprintf ('p', "Entering ProcessModuleInit\n");		  dbprintf ('p', "Entering ProcessModuleInit\n");
  QueueInit (&freepcbs);					  QueueInit (&freepcbs);
  for (i = 0; i< NUM_OF_RUNQUEUE; i++)				  for (i = 0; i< NUM_OF_RUNQUEUE; i++)
    QueueInit (&runQueue[i]);					    QueueInit (&runQueue[i]);
  QueueInit (&waitQueue);					  QueueInit (&waitQueue);
  QueueInit (&zombieQueue);					  QueueInit (&zombieQueue);
  for (i = 0; i < PROCESS_MAX_PROCS; i++) {			  for (i = 0; i < PROCESS_MAX_PROCS; i++) {
    dbprintf ('p', "Initializing PCB %d @ 0x%x.\n", i, &(pcbs	    dbprintf ('p', "Initializing PCB %d @ 0x%x.\n", i, &(pcbs
    pcbs[i].flags = PROCESS_STATUS_FREE;			    pcbs[i].flags = PROCESS_STATUS_FREE;
    QueueLinkInit (&(pcbs[i].l), (void *)&pcbs[i]);		    QueueLinkInit (&(pcbs[i].l), (void *)&pcbs[i]);
    QueueInsertFirst(&freepcbs, &(pcbs[i].l));			    QueueInsertFirst(&freepcbs, &(pcbs[i].l));
  }								  }
  currentPCB = NULL;						  currentPCB = NULL;
  dbprintf ('p', "Leaving ProcessModuleInit\n");		  dbprintf ('p', "Leaving ProcessModuleInit\n");
}								}
							      |
							      >
//-----------------------------------------------------------	//-----------------------------------------------------------
//								//
//	ProcessSetStatus					//	ProcessSetStatus
//								//
//	Set the status of a process.				//	Set the status of a process.
//								//
//-----------------------------------------------------------	//-----------------------------------------------------------
void							      |	  void
ProcessSetStatus (PCB *pcb, int status)				ProcessSetStatus (PCB *pcb, int status)
{								{
  pcb->flags &= ~PROCESS_STATUS_MASK;				  pcb->flags &= ~PROCESS_STATUS_MASK;
  pcb->flags |= status;						  pcb->flags |= status;
}								}

							      >
//-----------------------------------------------------------	//-----------------------------------------------------------
//								//
//	ProcessFreeResources					//	ProcessFreeResources
//								//
//	Free the resources associated with a process.  This a	//	Free the resources associated with a process.  This a
//	process isn't currently on any queue.			//	process isn't currently on any queue.
//								//
//-----------------------------------------------------------	//-----------------------------------------------------------
void							      |	  void
ProcessFreeResources (PCB *pcb)					ProcessFreeResources (PCB *pcb)
{								{
  int		i;						  int		i;
  int		npages;						  int		npages;

							      >
  QueueInsertLast (&freepcbs, &pcb->l);				  QueueInsertLast (&freepcbs, &pcb->l);
  // Free the process's memory.  This is easy with a one-leve	  // Free the process's memory.  This is easy with a one-leve
  // table, but could get more complex with two-level page ta	  // table, but could get more complex with two-level page ta
  npages = pcb->npages;						  npages = pcb->npages;

							      >
  for (i=0; i<npages; i++)					  for (i=0; i<npages; i++)
  {								  {
    MemoryFreeSharedPte(pcb, i); // *MUST* be called before c	    MemoryFreeSharedPte(pcb, i); // *MUST* be called before c
    				 // MemoryFreePte. MemoryFree |	    // MemoryFreePte. MemoryFreePte does not know
				 // anything about shared pag |	    // anything about shared pages, and hence it
				 // might screw up big time   |	    // might screw up big time
  }								  }
  for (i = 0; i < pcb->npages; i++) {				  for (i = 0; i < pcb->npages; i++) {
    MemoryFreePte (pcb->pagetable[i]);				    MemoryFreePte (pcb->pagetable[i]);
  }								  }
  // Free the page allocated for the system stack		  // Free the page allocated for the system stack
  MemoryFreePage (pcb->sysStackArea / MEMORY_PAGE_SIZE);	  MemoryFreePage (pcb->sysStackArea / MEMORY_PAGE_SIZE);
  ProcessSetStatus (pcb, PROCESS_STATUS_FREE);			  ProcessSetStatus (pcb, PROCESS_STATUS_FREE);
}								}

							      >
//-----------------------------------------------------------	//-----------------------------------------------------------
//								//
//	ProcessSetResult					//	ProcessSetResult
//								//
//	Set the result returned to a process.  This is done b	//	Set the result returned to a process.  This is done b
//	the value into the current register save area for r1.	//	the value into the current register save area for r1.
//	context is restored, r1 will contain the return value	//	context is restored, r1 will contain the return value
//	routine should only be called from a trap.  Calling i	//	routine should only be called from a trap.  Calling i
//	times (such as an interrupt handler) will cause unpre	//	times (such as an interrupt handler) will cause unpre
//	results.						//	results.
//								//
//-----------------------------------------------------------	//-----------------------------------------------------------
void							      |	  void
ProcessSetResult (PCB * pcb, uint32 result)			ProcessSetResult (PCB * pcb, uint32 result)
{								{
  pcb->currentSavedFrame[PROCESS_STACK_IREG+1] = result;	  pcb->currentSavedFrame[PROCESS_STACK_IREG+1] = result;
}								}

							      |
							      >	//-----------------------------------------------------------
							      >	//
							      >	//  ProcessHighestPriority
							      >	//
							      >	//  Grabs the next process that should be run
							      >	//
							      >	//-----------------------------------------------------------
							      >
							      >
							      >	PCB *
							      >	ProcessHighestPriority() {
							      >	  PCB *ret = NULL;
							      >	  int i;
							      >
							      >
							      >	  for (i = 0; i < 32; i++) {
							      >	    if ((&runQueue[i])->nitems != 0) {
							      >	      dbprintf('p', "Found process to run in queue [%i]\n",i)
							      >	      ret = (PCB *)(QueueFirst(&runQueue[i])->object);
							      >	      break;
							      >	    }
							      >	  }
							      >
							      >
							      >	  return ret;
							      >	}
							      >
							      >
//-----------------------------------------------------------	//-----------------------------------------------------------
//								//
//	ProcessSchedule						//	ProcessSchedule
//								//
//	Schedule the next process to run.  If there are no pr	//	Schedule the next process to run.  If there are no pr
//	run, exit.  This means that there should be an idle l	//	run, exit.  This means that there should be an idle l
//	if you want to allow the system to "run" when there's	//	if you want to allow the system to "run" when there's
//	work to be done.					//	work to be done.
//								//
//	NOTE: the scheduler should only be called from a trap	//	NOTE: the scheduler should only be called from a trap
//	handler.  This way, interrupts are disabled.  Also, i	//	handler.  This way, interrupts are disabled.  Also, i
//	called consistently, and because it might be called f	//	called consistently, and because it might be called f
//	handler (the timer interrupt), it must ALWAYS be call	//	handler (the timer interrupt), it must ALWAYS be call
//	or interrupt handler.					//	or interrupt handler.
//								//
//	Note that this procedure doesn't actually START the n	//	Note that this procedure doesn't actually START the n
//	It only changes the currentPCB and other variables so	//	It only changes the currentPCB and other variables so
//	return from interrupt will restore a different contex	//	return from interrupt will restore a different contex
//	which was saved.					//	which was saved.
//								//
//-----------------------------------------------------------	//-----------------------------------------------------------
// You should modify this function to use 4.4BSD scheduling p	// You should modify this function to use 4.4BSD scheduling p
//								//
void							      |	  void
ProcessSchedule ()						ProcessSchedule ()
{								{
  PCB           *pcb;						  PCB           *pcb;
  int           i;					      |	  int           i, j, n;
  int temp;						      |	  int           atEndOfQueue = FALSE; // To be used as a bool
  dbprintf ('p', "Now entering ProcessSchedule (cur=0x%x, %d  |	  Link          *links[32];
            currentPCB, QueueLength (&runQueue));	      |
							      >
  // The OS exits if there's no runnable process.  This is a 	  // The OS exits if there's no runnable process.  This is a 
  // bug.  An easy solution to allowing no runnable "user" pr	  // bug.  An easy solution to allowing no runnable "user" pr
  // have an "idle" process that's simply an infinite loop.	  // have an "idle" process that's simply an infinite loop.
							      >	  /*  if (QueueEmpty (&runQueue)) {
							      >	      printf ("No runnable processes - exiting!\n");
							      >	      exitsim (); // NEVER RETURNS
							      >	      }*/
							      >	  dbprintf('p', "Entering ProcessSchedule [context switch] wi

//DHIRAJ CHAUDHARY begin//				      <

  currentPCB -> p_quanta = currentPCB -> p_quanta + 1;	      |	  currentPCB->p_quanta++;
  Track10Quanta++;					      <
//int temp;						      <
//Looking at highest priority queue.			      <
  for(temp = 0; temp<32; temp++)//confirm 31		      <
	{						      <
	  if (QueueEmpty (&runQueue[temp])) {		      <
	  	continue;				      <
		}					      <
	  else						      <
	    {						      <
		break;					      <
	    }						      <
	}						      <
	if(temp == 32)					      <
	{						      <
	//All queues empty				      <
//	printf ("No runnable processes - exiting!\n");	      <
	exitsim (); // NEVER RETURNS			      <
	}						      <
							      <
//  printf("hello DJ The Queue with highest priority is numbe <
							      <
  // Move the front of the queue to the end, if it is the run <
  pcb = (PCB *)((QueueFirst (&runQueue[temp]))->object);      <
  currentPCB->runtime = currentPCB->runtime + (my_timer_get() <


//Part 4 of question					      |	  totalQuanta++;
if(currentPCB->p_info == 1)				      <
{							      <
    printf(TIMESTRING1,currentPCB - pcbs);		      <
    printf(TIMESTRING2,currentPCB->runtime / 1000.0);	      <
    printf(TIMESTRING3,currentPCB - pcbs, currentPCB->prio);  <
}							      <


  processStartTime = my_timer_get();			      |	  pcb = ProcessHighestPriority();

if(!pcb)						      <
{							      <
printf("\nProcess not found in run queue\n");		      <
exitsim();						      <
}							      <

  if (pcb == currentPCB)				      |	  currentPCB->runtime += my_timer_get() - startTime;
  {							      <
    pcb->estcpu++;					      <
    QueueRemove (&pcb->l);				      <
    //Prio is same so insert in same queue		      <
    QueueInsertLast (&runQueue[(pcb->prio)/4], &pcb->l);//pen <

    x = (currentPCB -> p_quanta);			      <
    if(x % 4  == 0)					      <
	{						      <
							      <
//printf("\n\n\nOMG\n\n\n\n");				      <
	currentPCB->prio = PUSER + ((currentPCB->estcpu)/4) + <
	//pcb-> prio = PUSER + ((pcb->estcpu)/4) + (2*pcb->p_ <
   	 QueueRemove (&currentPCB->l);			      <
	//Time to insert in right queue after 4 quantum	      <
	 QueueInsertLast (&runQueue[currentPCB->prio/4], &cur <
	}						      <

							      >	  if (currentPCB->p_info == 1) {
							      >	    printf(TIMESTRING1, currentPCB - pcbs);
							      >	    printf(TIMESTRING2, currentPCB->runtime / (float)1000);
							      >	    printf(TIMESTRING3, currentPCB - pcbs, currentPCB->prio);
  }								  }

//10 quantum passed?? OK time to check all priorities.. :)    <
if(Track10Quanta % 10 == 0)				      <
{							      <

for(temp1 = 0; temp1<NUM_OF_RUNQUEUE; temp1++) 		      |	  startTime = my_timer_get();
	{						      <
	numOfProcessesInRunQueue = (&runQueue[temp1])->nitems <
	for(temp2 =0; temp2<numOfProcessesInRunQueue; temp2++ <
	{						      <
	pcb = (PCB *)((QueueFirst(&runQueue[temp1]))->object) <
//	pcb -> estcpu = ((double) (2/3) * pcb->estcpu) + (dou <
 pcb->estcpu = (int)((((float)2 * 1)/((float)2 * 1 + 1)) * pc <

	pcb->prio = PUSER + ((pcb->estcpu)/4) + (2*pcb->p_nic <
//	QueueRemove (&pcb -> l);			      <

							      >	  if (!pcb) {
							      >	    printf ("No runnable processes - exiting!\n");
							      >	    exitsim ();
							      >	  }

//printf("\n\nhello------>>>><<<<<<<<< %d\n\n",(&runQueue[12] <

    QueueRemove (&pcb->l);				      |	  dbprintf('p', "PCB (%p) currentPCB (%p)\n",pcb,currentPCB);

        //Time to insert in right queue after 10 quantum      <
        QueueInsertLast (&runQueue[(pcb->prio)/4], &pcb->l);/ <

	}						      <
	}						      <
//check highest priority queue.				      <
							      <
//printf("\n\nhello------>>>> %d\n\n",(&runQueue[12])->nitems <
							      <
  for(temp = 0; temp<NUM_OF_RUNQUEUE; temp++)//confirm 31     <
        {						      <
          if (QueueEmpty (&runQueue[temp])) {		      <
                continue;				      <
                }					      <
          else						      <
            {						      <
                break;					      <
            }						      <
        }						      <
        if(temp == 32)					      <
        {						      <
        //All queues empty				      <
        printf ("No runnable processes - exiting!\n");	      <
        exitsim (); // NEVER RETURNS			      <
        }						      <
							      <
//  printf("hello DJ The Queue with highest priority is numbe <
							      <
  // Move the front of the queue to the end, if it is the run <
  pcb = (PCB *)((QueueFirst (&runQueue[temp]))->object);      <
//currentPCB = pcb;					      <


if(pcb == currentPCB)					      |	  // If last run process is still the highest priority (ie. n
{							      |	  if (pcb == currentPCB) {
							      >	    currentPCB->estcpu++;
							      >

    QueueRemove (&pcb->l);					    QueueRemove (&pcb->l);
    QueueInsertLast (&runQueue[currentPCB->prio/4], &currentP |	    QueueInsertLast (&runQueue[pcb->runQueueNum], &pcb->l);

}							      <

//printf("\n\nhello------ %d\n\n",(&runQueue[12])->nitems);   |	    dbprintf('p', "\tProcess quanta: %i estcpu: %i\n",current
}							      |	    if((currentPCB->p_quanta % PROCESS_QUANTA_MAX) == 0) {
							      >	      dbprintf('p', "Recalculating priority of currentPCB\n")
							      >	      currentPCB->prio = PUSER + (currentPCB->estcpu/4) + (2*
							      >	      dbprintf('p', "run queue: %i new run queue: %i prio: %i


//Looking at highest priority queue.			      |	      currentPCB->runQueueNum = currentPCB->prio/4;
							      >	      QueueRemove(&currentPCB->l);
							      >	      QueueInsertLast(&runQueue[currentPCB->runQueueNum], &cu

  for(temp = 0; temp < NUM_OF_RUNQUEUE; temp++)//confirm 31   |
        {						      |	      dbprintf('p', "Recalculated priority\n");
          if (QueueEmpty (&runQueue[temp])) {		      |	    }
                continue;				      <
                }					      <
          else						      <
            {						      <
                break;					      <
            }						      <
}							      <
if(temp == 32)						      <
{							      <
//All queues empty					      <
        printf ("No runnable processes - exiting!\n");	      <
        exitsim (); // NEVER RETURNS			      <
}							      <
							      <
//printf("Test   %d",(&runQueue[temp])->nitems);	      <
							      <
  // Now, run the one at the head of the queue.		      <
  pcb = (PCB *)((QueueFirst (&runQueue[temp]))->object);      <
  currentPCB = pcb;					      <
  dbprintf ('p',"About to switch to PCB 0x%x,flags=0x%x @ 0x% <
            pcb, pcb->flags,				      <
            pcb->sysStackPtr[PROCESS_STACK_IAR]);	      <
							      <
  // Clean up zombie processes here.  This is done at interru <
  // because it can't be done while the process might still b <
  while (!QueueEmpty (&zombieQueue)) {			      <
    pcb = (PCB *)(QueueFirst (&zombieQueue)->object);	      <
    dbprintf ('p', "Freeing zombie PCB 0x%x.\n", pcb);	      <
    QueueRemove (&pcb->l);				      <
    ProcessFreeResources (pcb);				      <
  }								  }
  // Set the timer so this process gets at most a fixed quant <
  TimerSet (processQuantum);				      <
  dbprintf ('p', "Leaving ProcessSchedule (cur=0x%x)\n", curr <
//printf("\n\nhello------ %d\n\n",(&runQueue[12])->nitems);   <


							      >	  if(totalQuanta % TOTAL_QUANTA_MAX == 0) {
							      >	    dbprintf('p', "Full reshuffle\n");
							      >	    // dbprintf('p', "Process quanta exceeded max\n");
							      >	    // Store all the tails of all of the RunQueues
							      >	    for(i = 0; i < 32; i++) {
							      >	      links[i] = QueueLast(&runQueue[i]);
							      >	    }
							      >	    dbprintf('p', "Last links registered\n");
							      >
							      >
							      >	    for(i = 0; i < 32; i++) {
							      >	      //        if(QueueEmpty(&runQueue[i])) atEndOfQueue = T
							      >	      n = (&runQueue[i])->nitems;
							      >
							      >
							      >	      //        while(!atEndOfQueue) {
							      >	      for (j = 0; j < n; j++) {
							      >	        pcb = (PCB *)((QueueFirst(&runQueue[i]))->object);
							      >	        pcb->estcpu = (int)((((float)2 * pcb->load)/((float)2
							      >	        pcb->prio = PUSER + (pcb->estcpu/4) + (2 * pcb->p_nic
							      >	        dbprintf('p', "\tRun queue shift (%p->%d)\n",pcb,pcb-
							      >
							      >
							      >	        dbprintf('p', "At link: %p for last link: %p\n",&pcb-
							      >	        if(links[i] == &pcb->l || (&pcb->l)->next == NULL) at
							      >
							      >
							      >	        pcb->runQueueNum = pcb->prio/4;
							      >	        QueueRemove(&pcb->l);
							      >	        QueueInsertLast(&runQueue[pcb->runQueueNum], &pcb->l)
							      >	      }
							      >	    }
							      >
							      >
							      >	    pcb = ProcessHighestPriority();
							      >	    if (currentPCB == pcb) {
							      >	      QueueRemove(&currentPCB->l);
							      >	      QueueInsertLast(&runQueue[currentPCB->runQueueNum], &cu
							      >	    }
							      >	    }
							      >	    //}
							      >
							      >
							      >	    pcb = ProcessHighestPriority();
							      >
							      >
							      >	    //  }
							      >
							      >
							      >	    currentPCB = pcb;
							      >
							      >
							      >	    // currentPCB = ProcessHighestPriority();
							      >
							      >
							      >	    // Move the front of the queue to the end, if it is the r
							      >	    /*
							      >	       pcb = (PCB *)((QueueFirst (&runQueue))->object);
							      >	       if (pcb == currentPCB)
							      >	       {
							      >	       QueueRemove (&pcb->l);
							      >	       QueueInsertLast (&runQueue, &pcb->l);
							      >	       }
							      >
							      >
							      >	    // Now, run the one at the head of the queue.
							      >	    pcb = (PCB *)((QueueFirst (&runQueue))->object);
							      >	    currentPCB = pcb;
							      >	    dbprintf ('p',"About to switch to PCB 0x%x,flags=0x%x @ 0
							      >	    pcb, pcb->flags,
							      >	    pcb->sysStackPtr[PROCESS_STACK_IAR]);
							      >	     */
							      >
							      >
							      >	    // Clean up zombie processes here.  This is done at inter
							      >	    // because it can't be done while the process might still
							      >	    while (!QueueEmpty (&zombieQueue)) {
							      >	      pcb = (PCB *)(QueueFirst (&zombieQueue)->object);
							      >	      dbprintf ('p', "Freeing zombie PCB 0x%x.\n", pcb);
							      >	      QueueRemove (&pcb->l);
							      >	      ProcessFreeResources (pcb);
							      >	    }
							      >	    // Set the timer so this process gets at most a fixed qua
							      >	    TimerSet (processQuantum);
							      >	    dbprintf ('p', "Leaving ProcessSchedule (cur=0x%x)\n", cu
}								}
							      |
							      >
//-----------------------------------------------------------	//-----------------------------------------------------------
//								//
//	ProcessSuspend						//	ProcessSuspend
//								//
//	Place a process in suspended animation until it's	//	Place a process in suspended animation until it's
//	awakened by Processwakeup.				//	awakened by Processwakeup.
//								//
//	NOTE: This must only be called from an interrupt or t	//	NOTE: This must only be called from an interrupt or t
//	should be immediately followed by ProcessSchedule().	//	should be immediately followed by ProcessSchedule().
//								//
//-----------------------------------------------------------	//-----------------------------------------------------------
void							      |	  void
ProcessSuspend (PCB *suspend)					ProcessSuspend (PCB *suspend)
{								{

							      >
  // Make sure it's already a runnable process.			  // Make sure it's already a runnable process.
  dbprintf ('p', "Suspending PCB 0x%x (%s).\n", suspend, susp |	  dbprintf ('p', "Suspending PCB 0x%x (%s) at %d.\n", suspend
suspend->sleeptime = my_timer_get();			      |	  suspend->sleeptime = my_timer_get();
  ASSERT (suspend->flags & PROCESS_STATUS_RUNNABLE,		  ASSERT (suspend->flags & PROCESS_STATUS_RUNNABLE,
	  "Trying to suspend a non-running process!\n");      |	      "Trying to suspend a non-running process!\n");
  ProcessSetStatus (suspend, PROCESS_STATUS_WAITING);		  ProcessSetStatus (suspend, PROCESS_STATUS_WAITING);
  QueueRemove (&suspend->l);					  QueueRemove (&suspend->l);
  QueueInsertLast (&waitQueue, &suspend->l);			  QueueInsertLast (&waitQueue, &suspend->l);
}								}

							      >
//-----------------------------------------------------------	//-----------------------------------------------------------
//								//
//	ProcessWakeup						//	ProcessWakeup
//								//
//	Wake up a process from its slumber.  This only involv	//	Wake up a process from its slumber.  This only involv
//	it on the run queue; it's not guaranteed to be the ne	//	it on the run queue; it's not guaranteed to be the ne
//	run.							//	run.
//								//
//	NOTE: This must only be called from an interrupt or t	//	NOTE: This must only be called from an interrupt or t
//	need not be followed immediately by ProcessSchedule()	//	need not be followed immediately by ProcessSchedule()
//	the currently running process is unaffected.		//	the currently running process is unaffected.
//								//
//-----------------------------------------------------------	//-----------------------------------------------------------
void							      |	  void
ProcessWakeup (PCB *wakeup)					ProcessWakeup (PCB *wakeup)
{								{
double  t_estcpuFinal, t_estcpu;			      |	  int i, sleeptime_inseconds;
							      >	  float temp_estcpu, power;
							      >
							      >
  dbprintf ('p',"Waking up PCB 0x%x.\n", wakeup);		  dbprintf ('p',"Waking up PCB 0x%x.\n", wakeup);
  // Make sure it's not yet a runnable process.			  // Make sure it's not yet a runnable process.
  ASSERT (wakeup->flags & PROCESS_STATUS_WAITING,		  ASSERT (wakeup->flags & PROCESS_STATUS_WAITING,
          "Trying to wake up a non-sleeping process!\n");     |	      "Trying to wake up a non-sleeping process!\n");
if((my_timer_get()-wakeup->sleeptime)/1000 >= 1)	      <
{							      <


t_estcpuFinal =((((float)2 * 1)/((float)2 * 1 + 1)) * wakeup- |	  sleeptime_inseconds = (my_timer_get() - wakeup->sleeptime)/
t_estcpu =((((float)2 * 1)/((float)2 * 1 + 1)) * wakeup->estc |
							      >
							      >	  // Adjust the estimated CPU time
							      >	  if(sleeptime_inseconds >= 1) {
							      >	    temp_estcpu = ((((float)2 * wakeup->load)/((float)2 * wak
							      >	    power = temp_estcpu;
							      >	    for(i = 1; i < sleeptime_inseconds; i++) {
							      >	      temp_estcpu *= power;  // To the power of sleeptime_ins
							      >	    }
							      >	    wakeup->estcpu = (int)temp_estcpu;
							      >	  }

for(temp1=0;temp1<(int)((my_timer_get()-wakeup->sleeptime)/10 <
{							      <
   t_estcpuFinal = t_estcpuFinal *  t_estcpu;		      <
}							      <
wakeup->estcpu = (int)t_estcpuFinal;			      <
}							      <
 wakeup->prio = PUSER + (wakeup->estcpu/4) + (2*wakeup->p_nic <

							      >	  // Recalculate priority
							      >	  wakeup->prio = PUSER + (wakeup->estcpu/4) + (2*wakeup->p_ni
							      >	  wakeup->runQueueNum = wakeup->prio/4;
							      >
							      >
							      >	  // Put the process on a run queue based on Priority
  ProcessSetStatus (wakeup, PROCESS_STATUS_RUNNABLE);		  ProcessSetStatus (wakeup, PROCESS_STATUS_RUNNABLE);
  QueueRemove (&wakeup->l);					  QueueRemove (&wakeup->l);
  QueueInsertLast (&runQueue[(wakeup->prio)/4], &wakeup->l);  |	  QueueInsertLast (&runQueue[wakeup->runQueueNum], &wakeup->l
							      >

}								}

							      |
							      >
							      >
//-----------------------------------------------------------	//-----------------------------------------------------------
//								//
//	ProcessDestroy						//	ProcessDestroy
//								//
//	Destroy a process by setting its status to zombie and	//	Destroy a process by setting its status to zombie and
//	on the zombie queue.  The next time the scheduler is 	//	on the zombie queue.  The next time the scheduler is 
//	process will be marked as free.  We can't necessarily	//	process will be marked as free.  We can't necessarily
//	because we might be the currently running process.	//	because we might be the currently running process.
//								//
//	NOTE: This must only be called from an interrupt or t	//	NOTE: This must only be called from an interrupt or t
//	it need not be followed immediately by a ProcessSched	//	it need not be followed immediately by a ProcessSched
//	the process can continue running.			//	the process can continue running.
//								//
//-----------------------------------------------------------	//-----------------------------------------------------------
void							      |	  void
ProcessDestroy (PCB *pcb)					ProcessDestroy (PCB *pcb)
{								{
  dbprintf('p', "Entering ProcessDestroy for 0x%x.\n", pcb);	  dbprintf('p', "Entering ProcessDestroy for 0x%x.\n", pcb);
  ProcessSetStatus (pcb, PROCESS_STATUS_ZOMBIE);		  ProcessSetStatus (pcb, PROCESS_STATUS_ZOMBIE);
  QueueRemove (&pcb->l);					  QueueRemove (&pcb->l);
  QueueInsertFirst (&zombieQueue, &pcb->l);			  QueueInsertFirst (&zombieQueue, &pcb->l);
  dbprintf('p', "Leaving ProcessDestroy for 0x%x.\n", pcb);	  dbprintf('p', "Leaving ProcessDestroy for 0x%x.\n", pcb);
}								}

							      >
//-----------------------------------------------------------	//-----------------------------------------------------------
//								//
//	ProcessExit						//	ProcessExit
//								//
//	This routine is called to exit from a system process.	//	This routine is called to exit from a system process.
//	calls an exit trap, which will be caught to exit the 	//	calls an exit trap, which will be caught to exit the 
//								//
//-----------------------------------------------------------	//-----------------------------------------------------------
static								static
void							      |	  void
ProcessExit ()							ProcessExit ()
{								{
  exit ();							  exit ();
}								}

							      >
uint32 get_argument(char *string)				uint32 get_argument(char *string)
{								{
  static char *str;						  static char *str;
  static int location=0;					  static int location=0;
  int location2;						  int location2;

							      >
  if(string)							  if(string)
  {								  {
    str=string;							    str=string;
    location = 0;						    location = 0;
  }								  }

							      >
  location2 = location;						  location2 = location;

							      >
  if(str[location]=='\0'||location>=99)				  if(str[location]=='\0'||location>=99)
    return 0;							    return 0;

							      >
  for(;location<100;location++)					  for(;location<100;location++)
  {								  {
    if(str[location]=='\0')					    if(str[location]=='\0')
    {								    {
      location++;						      location++;
      break;							      break;
    }								    }
  }								  }
  return location2;						  return location2;
}								}


							      >
							      >
//-----------------------------------------------------------	//-----------------------------------------------------------
//								//
//	ProcessFork						//	ProcessFork
//								//
//	Create a new process and make it runnable.  This invo	//	Create a new process and make it runnable.  This invo
//	following steps:					//	following steps:
//	* Allocate resources for the process (PCB, memory, et	//	* Allocate resources for the process (PCB, memory, et
//	* Initialize the resources				//	* Initialize the resources
//	* Place the PCB on the runnable queue			//	* Place the PCB on the runnable queue
//								//
//	NOTE: This code has been tested for system processes,	//	NOTE: This code has been tested for system processes,
//	for user processes.					//	for user processes.
//								//
//-----------------------------------------------------------	//-----------------------------------------------------------
int							      |	  int
ProcessFork (VoidFunc func, uint32 param, int p_nice, int p_i	ProcessFork (VoidFunc func, uint32 param, int p_nice, int p_i
//p_nice in PCB, p_info, prio, estcpu PCB		      <
							      <
{								{
  int		i, j, fd, n;					  int		i, j, fd, n;
  Link		*l;						  Link		*l;
  int		start, codeS, codeL, dataS, dataL;		  int		start, codeS, codeL, dataS, dataL;
  uint32	*stackframe;					  uint32	*stackframe;
  int		newPage;					  int		newPage;
  PCB		*pcb;						  PCB		*pcb;
  int	addr = 0;						  int	addr = 0;
  int		intrs;						  int		intrs;
  unsigned char buf[100];					  unsigned char buf[100];
  uint32 dum[MAX_ARGS+8], count, offset;			  uint32 dum[MAX_ARGS+8], count, offset;
  char *str;							  char *str;


							      >
							      >
  intrs = DisableIntrs ();					  intrs = DisableIntrs ();
  dbprintf ('I', "Old interrupt value was 0x%x.\n", intrs);	  dbprintf ('I', "Old interrupt value was 0x%x.\n", intrs);
  dbprintf ('p', "Entering ProcessFork args=0x%x 0x%x %s %d\n	  dbprintf ('p', "Entering ProcessFork args=0x%x 0x%x %s %d\n
	    param, name, isUser);			      |	      param, name, isUser);
  // Get a free PCB for the new process				  // Get a free PCB for the new process
  if (QueueEmpty (&freepcbs)) {					  if (QueueEmpty (&freepcbs)) {
    printf ("FATAL error: no free processes!\n");		    printf ("FATAL error: no free processes!\n");
    exitsim ();	// NEVER RETURNS!				    exitsim ();	// NEVER RETURNS!
  }								  }
  l = QueueFirst (&freepcbs);					  l = QueueFirst (&freepcbs);
  dbprintf ('p', "Got a link @ 0x%x\n", l);			  dbprintf ('p', "Got a link @ 0x%x\n", l);
  QueueRemove (l);						  QueueRemove (l);
  pcb = (PCB *)(l->object);					  pcb = (PCB *)(l->object);
  // This prevents someone else from grabbing this process	  // This prevents someone else from grabbing this process
  ProcessSetStatus (pcb, PROCESS_STATUS_RUNNABLE);		  ProcessSetStatus (pcb, PROCESS_STATUS_RUNNABLE);

							      >
  // At this point, the PCB is allocated and nobody else can 	  // At this point, the PCB is allocated and nobody else can 
  // However, it's not in the run queue, so it won't be run. 	  // However, it's not in the run queue, so it won't be run. 
  // can turn on interrupts here.				  // can turn on interrupts here.
  dbprintf ('I', "Before restore interrupt value is 0x%x.\n",	  dbprintf ('I', "Before restore interrupt value is 0x%x.\n",
  RestoreIntrs (intrs);						  RestoreIntrs (intrs);
  dbprintf ('I', "New interrupt value is 0x%x.\n", CurrentInt	  dbprintf ('I', "New interrupt value is 0x%x.\n", CurrentInt

							      >
  // Copy the process name into the PCB.			  // Copy the process name into the PCB.
  dstrcpy (pcb->name, name);					  dstrcpy (pcb->name, name);

							      >
  //---------------------------------------------------------	  //---------------------------------------------------------
  // This section initializes the memory for this process	  // This section initializes the memory for this process
  //---------------------------------------------------------	  //---------------------------------------------------------
  // For now, we'll use one user page and a page for the syst	  // For now, we'll use one user page and a page for the syst
  // For system processes, though, all pages must be contiguo	  // For system processes, though, all pages must be contiguo
  // Of course, system processes probably need just a single 	  // Of course, system processes probably need just a single 
  // their stack, and don't need any code or data pages alloc	  // their stack, and don't need any code or data pages alloc
  pcb->npages = 1;						  pcb->npages = 1;
  newPage = MemoryAllocPage ();					  newPage = MemoryAllocPage ();
  if (newPage == 0) {						  if (newPage == 0) {
    printf ("aFATAL: couldn't allocate memory - no free pages	    printf ("aFATAL: couldn't allocate memory - no free pages
    exitsim ();	// NEVER RETURNS!				    exitsim ();	// NEVER RETURNS!
  }								  }
  pcb->pagetable[0] = MemorySetupPte (newPage);			  pcb->pagetable[0] = MemorySetupPte (newPage);
  newPage = MemoryAllocPage ();					  newPage = MemoryAllocPage ();
  if (newPage == 0) {						  if (newPage == 0) {
    printf ("bFATAL: couldn't allocate system stack - no free	    printf ("bFATAL: couldn't allocate system stack - no free
    exitsim ();	// NEVER RETURNS!				    exitsim ();	// NEVER RETURNS!
  }								  }
  pcb->sysStackArea = newPage * MEMORY_PAGE_SIZE;		  pcb->sysStackArea = newPage * MEMORY_PAGE_SIZE;


							      >
							      >
  //---------------------------------------			  //---------------------------------------
  // Lab3: initialized pcb member for your scheduling algorit	  // Lab3: initialized pcb member for your scheduling algorit
							      >	  if((isUser && p_nice < 0) || p_nice > 19) {  // p_nice shou
							      >	    pcb->p_nice = 0;
							      >	  }
							      >	  else pcb->p_nice      = p_nice;
							      >	  pcb->estcpu       		= 0;
							      >	  pcb->runtime      		= 0;
							      >	  //  pcb->runtime_lastrun  = -1;   // -1 to show hasn't been
							      >	  pcb->sleeptime	      = 0;
							      >	  pcb->prio		          = PUSER;
							      >	  pcb->runQueueNum	    = (pcb->prio)/4;
							      >	  pcb->load		          = 1;
							      >	  pcb->p_info		        = p_info;
							      >	  pcb->p_quanta		      = 0;
  //--------------------------------------			  //--------------------------------------

//Dhiraj Chaudhary Start				      <
if((p_nice<0)||(p_nice>19))				      <
{							      <
pcb->p_nice = 0;					      <
}							      <
else							      <
{							      <
pcb -> p_nice = p_nice ;				      <
}							      <
pcb -> p_info = p_info;					      <
pcb -> estcpu = 0.0;					      <
pcb -> p_quanta = 0;					      <
pcb->prio = PUSER;					      <

//Dhiraj Chaudhary End					      <


 //---------------------------------------------------------- |	  //---------------------------------------------------------
  // Stacks grow down from the top.  The current system stack	  // Stacks grow down from the top.  The current system stack
  // to be set to the bottom of the interrupt stack frame, wh	  // to be set to the bottom of the interrupt stack frame, wh
  // high end (address-wise) of the system stack.		  // high end (address-wise) of the system stack.
  stackframe = ((uint32 *)(pcb->sysStackArea + MEMORY_PAGE_SI	  stackframe = ((uint32 *)(pcb->sysStackArea + MEMORY_PAGE_SI
    (PROCESS_STACK_FRAME_SIZE + 8);				    (PROCESS_STACK_FRAME_SIZE + 8);
  // The system stack pointer is set to the base of the curre	  // The system stack pointer is set to the base of the curre
  // stack frame.						  // stack frame.
  pcb->sysStackPtr = stackframe;				  pcb->sysStackPtr = stackframe;
  // The current stack frame pointer is set to the same thing	  // The current stack frame pointer is set to the same thing
  pcb->currentSavedFrame = stackframe;				  pcb->currentSavedFrame = stackframe;

							      >
  dbprintf ('p',						  dbprintf ('p',
	    "Setting up PCB @ 0x%x (sys stack=0x%x, mem=0x%x, |	      "Setting up PCB @ 0x%x (sys stack=0x%x, mem=0x%x, size=
	    pcb, pcb->sysStackArea, pcb->pagetable[0],	      |	      pcb, pcb->sysStackArea, pcb->pagetable[0],
	    pcb->npages * MEMORY_PAGE_SIZE);		      |	      pcb->npages * MEMORY_PAGE_SIZE);
							      >

  //---------------------------------------------------------	  //---------------------------------------------------------
  // This section sets up the stack frame for the process.  T	  // This section sets up the stack frame for the process.  T
  // so that the frame looks to the interrupt handler like th	  // so that the frame looks to the interrupt handler like th
  // was "suspended" right before it began execution.  The st	  // was "suspended" right before it began execution.  The st
  // mechanism of swapping in the registers and returning to 	  // mechanism of swapping in the registers and returning to 
  // where it was "interrupted" will then work.			  // where it was "interrupted" will then work.
  //---------------------------------------------------------	  //---------------------------------------------------------

							      >
  // The previous stack frame pointer is set to 0, meaning th	  // The previous stack frame pointer is set to 0, meaning th
  // previous frame.						  // previous frame.
  stackframe[PROCESS_STACK_PREV_FRAME] = 0;			  stackframe[PROCESS_STACK_PREV_FRAME] = 0;

							      >
  // Set the base of the level 1 page table.  If there's only	  // Set the base of the level 1 page table.  If there's only
  // table level, this is it.  For 2-level page tables, put t	  // table level, this is it.  For 2-level page tables, put t
  // of the level 1 page table here.  For 2-level page tables	  // of the level 1 page table here.  For 2-level page tables
  // have to build up the necessary tables....			  // have to build up the necessary tables....
  stackframe[PROCESS_STACK_PTBASE] = (uint32)&(pcb->pagetable	  stackframe[PROCESS_STACK_PTBASE] = (uint32)&(pcb->pagetable

							      >
  // Set the size (maximum number of entries) of the level 1 	  // Set the size (maximum number of entries) of the level 1 
  // In our case, it's just one page, but it could be larger.	  // In our case, it's just one page, but it could be larger.
  stackframe[PROCESS_STACK_PTSIZE] = pcb->npages;		  stackframe[PROCESS_STACK_PTSIZE] = pcb->npages;

							      >
  // Set the number of bits for both the level 1 and level 2 	  // Set the number of bits for both the level 1 and level 2 
  // This can be changed on a per-process basis if desired.  	  // This can be changed on a per-process basis if desired.  
  // though, it's fixed.					  // though, it's fixed.
  stackframe[PROCESS_STACK_PTBITS] = (MEMORY_L1_PAGE_SIZE_BIT	  stackframe[PROCESS_STACK_PTBITS] = (MEMORY_L1_PAGE_SIZE_BIT
					  + (MEMORY_L2_PAGE_S |	      + (MEMORY_L2_PAGE_SIZE_BITS << 16));
							      >
							      >


  if (isUser) {							  if (isUser) {
    dbprintf ('p', "About to load %s\n", name);			    dbprintf ('p', "About to load %s\n", name);
    fd = ProcessGetCodeInfo (name, &start, &codeS, &codeL, &d	    fd = ProcessGetCodeInfo (name, &start, &codeS, &codeL, &d
    if (fd < 0) {						    if (fd < 0) {
							      >	      dbprintf('p', "Could not get code info for: %s (%i)\n",
      // Free newpage and pcb so we don't run out...		      // Free newpage and pcb so we don't run out...
      ProcessFreeResources (pcb);				      ProcessFreeResources (pcb);
      return (-1);						      return (-1);
    }								    }
    dbprintf ('p', "File %s -> start=0x%08x\n", name, start);	    dbprintf ('p', "File %s -> start=0x%08x\n", name, start);
    dbprintf ('p', "File %s -> code @ 0x%08x (size=0x%08x)\n"	    dbprintf ('p', "File %s -> code @ 0x%08x (size=0x%08x)\n"
	      codeL);					      |	        codeL);
    dbprintf ('p', "File %s -> data @ 0x%08x (size=0x%08x)\n"	    dbprintf ('p', "File %s -> data @ 0x%08x (size=0x%08x)\n"
	      dataL);					      |	        dataL);
    while ((n = ProcessGetFromFile (fd, buf, &addr, sizeof (b	    while ((n = ProcessGetFromFile (fd, buf, &addr, sizeof (b
      dbprintf ('p', "Placing %d bytes at vaddr %08x.\n", n, 	      dbprintf ('p', "Placing %d bytes at vaddr %08x.\n", n, 
      // Copy the data to user memory.  Note that the user me	      // Copy the data to user memory.  Note that the user me
      // have enough space so that this copy will succeed!	      // have enough space so that this copy will succeed!
      MemoryCopySystemToUser (pcb, buf, addr - n, n);		      MemoryCopySystemToUser (pcb, buf, addr - n, n);
    }								    }
    FsClose (fd);						    FsClose (fd);
    stackframe[PROCESS_STACK_ISR] = PROCESS_INIT_ISR_USER;	    stackframe[PROCESS_STACK_ISR] = PROCESS_INIT_ISR_USER;
    // Set the initial stack pointer correctly.  Currently, i	    // Set the initial stack pointer correctly.  Currently, i
    // to the top of the (single) user address space allocate	    // to the top of the (single) user address space allocate
    // process.							    // process.
    str = (char *)param;					    str = (char *)param;
    stackframe[PROCESS_STACK_IREG+29] = MEMORY_PAGE_SIZE - SI	    stackframe[PROCESS_STACK_IREG+29] = MEMORY_PAGE_SIZE - SI
    // Copy the initial parameter to the top of stack		    // Copy the initial parameter to the top of stack

							      >
    MemoryCopySystemToUser (pcb, (char *)str,			    MemoryCopySystemToUser (pcb, (char *)str,
			    (char *)stackframe[PROCESS_STACK_ |	        (char *)stackframe[PROCESS_STACK_IREG+29],
			    SIZE_ARG_BUFF-32);		      |	        SIZE_ARG_BUFF-32);
							      >

    offset = get_argument((char *)param);			    offset = get_argument((char *)param);

							      >
    dum[2] = MEMORY_PAGE_SIZE - SIZE_ARG_BUFF + offset;		    dum[2] = MEMORY_PAGE_SIZE - SIZE_ARG_BUFF + offset;
    for(count=3;;count++)					    for(count=3;;count++)
    {								    {
      offset=get_argument(NULL);				      offset=get_argument(NULL);
      dum[count] = MEMORY_PAGE_SIZE - SIZE_ARG_BUFF + offset;	      dum[count] = MEMORY_PAGE_SIZE - SIZE_ARG_BUFF + offset;
      if(offset==0)						      if(offset==0)
      {								      {
        break;							        break;
      }								      }
    }								    }
    dum[0] = count-2;						    dum[0] = count-2;
    dum[1] = MEMORY_PAGE_SIZE - SIZE_ARG_BUFF - (count-2)*4;	    dum[1] = MEMORY_PAGE_SIZE - SIZE_ARG_BUFF - (count-2)*4;
    MemoryCopySystemToUser (pcb, (char *)dum,			    MemoryCopySystemToUser (pcb, (char *)dum,
			    (char *)(stackframe[PROCESS_STACK |	        (char *)(stackframe[PROCESS_STACK_IREG+29]-count*4),
			    (count)*sizeof(uint32));	      |	        (count)*sizeof(uint32));
    stackframe[PROCESS_STACK_IREG+29] -= 4*count;		    stackframe[PROCESS_STACK_IREG+29] -= 4*count;
    // Set the correct address at which to execute a user pro	    // Set the correct address at which to execute a user pro
    stackframe[PROCESS_STACK_IAR] = (uint32)start;		    stackframe[PROCESS_STACK_IAR] = (uint32)start;
    pcb->flags |= PROCESS_TYPE_USER;				    pcb->flags |= PROCESS_TYPE_USER;
  } else {							  } else {
    // Set r31 to ProcessExit().  This will only be called fo	    // Set r31 to ProcessExit().  This will only be called fo
    // process; user processes do an exit() trap.		    // process; user processes do an exit() trap.
    stackframe[PROCESS_STACK_IREG+31] = (uint32)ProcessExit;	    stackframe[PROCESS_STACK_IREG+31] = (uint32)ProcessExit;

							      >
    // Set the stack register to the base of the system stack	    // Set the stack register to the base of the system stack
    stackframe[PROCESS_STACK_IREG+29]=pcb->sysStackArea + MEM	    stackframe[PROCESS_STACK_IREG+29]=pcb->sysStackArea + MEM

							      >
    // Set the initial parameter properly by placing it on th	    // Set the initial parameter properly by placing it on th
    // at the location pointed to by the "saved" stack pointe	    // at the location pointed to by the "saved" stack pointe
    *((uint32 *)(stackframe[PROCESS_STACK_IREG+29])) = param;	    *((uint32 *)(stackframe[PROCESS_STACK_IREG+29])) = param;

							      >
    // Set up the initial address at which to execute.  This 	    // Set up the initial address at which to execute.  This 
    // placing the address into the IAR slot of the stack fra	    // placing the address into the IAR slot of the stack fra
    stackframe[PROCESS_STACK_IAR] = (uint32)func;		    stackframe[PROCESS_STACK_IAR] = (uint32)func;

							      >
    // Set the initial value for the interrupt status registe	    // Set the initial value for the interrupt status registe
    stackframe[PROCESS_STACK_ISR] = PROCESS_INIT_ISR_SYS;	    stackframe[PROCESS_STACK_ISR] = PROCESS_INIT_ISR_SYS;

							      >
    // Mark this as a system process.				    // Mark this as a system process.
    pcb->flags |= PROCESS_TYPE_SYSTEM;				    pcb->flags |= PROCESS_TYPE_SYSTEM;
  }								  }

							      >
  // Place the PCB onto the run queue.				  // Place the PCB onto the run queue.
  intrs = DisableIntrs ();					  intrs = DisableIntrs ();
							      |	  dbprintf('p', "Inserting last [%i] (%p, %p)\n",PUSER/4,l,l-
  QueueInsertLast (&runQueue[(pcb->prio)/4], l); //all in 1.  |	  QueueInsertLast (&runQueue[PUSER/4], l);
  RestoreIntrs (intrs);						  RestoreIntrs (intrs);

							      >
  // If this is the first process, make it the current one	  // If this is the first process, make it the current one
  if (currentPCB == NULL) {					  if (currentPCB == NULL) {
    dbprintf ('p', "Setting currentPCB=0x%x, stackframe=0x%x\	    dbprintf ('p', "Setting currentPCB=0x%x, stackframe=0x%x\
	      pcb, pcb->currentSavedFrame);		      |	        pcb, pcb->currentSavedFrame);
    currentPCB = pcb;						    currentPCB = pcb;
  }								  }
  dbprintf ('p', "Leaving ProcessFork (%s)\n", name);		  dbprintf ('p', "Leaving ProcessFork (%s)\n", name);
  // Return the process number (found by subtracting the PCB 	  // Return the process number (found by subtracting the PCB 
  // from the base of the PCB array).				  // from the base of the PCB array).
  return (pcb - pcbs);						  return (pcb - pcbs);
}								}
							      |
							      >
//-----------------------------------------------------------	//-----------------------------------------------------------
//								//
//	getxvalue						//	getxvalue
//								//
//	Convert a hex digit into an actual value.		//	Convert a hex digit into an actual value.
//								//
//-----------------------------------------------------------	//-----------------------------------------------------------
static								static
inline								inline
int							      |	  int
getxvalue (int x)						getxvalue (int x)
{								{
  if ((x >= '0') && (x <= '9')) {				  if ((x >= '0') && (x <= '9')) {
    return (x - '0');						    return (x - '0');
  } else if ((x >= 'a') && (x <= 'f')) {			  } else if ((x >= 'a') && (x <= 'f')) {
    return (x + 10 - 'a');					    return (x + 10 - 'a');
  } else if ((x >= 'A') && (x <= 'F')) {			  } else if ((x >= 'A') && (x <= 'F')) {
    return (x + 10 - 'A');					    return (x + 10 - 'A');
  } else {							  } else {
    return (0);							    return (0);
  }								  }
}								}
							      |
							      >
//-----------------------------------------------------------	//-----------------------------------------------------------
//								//
//	ProcessGetCodeSizes					//	ProcessGetCodeSizes
//								//
//	Get the code sizes (stack & data) for a file.  A file	//	Get the code sizes (stack & data) for a file.  A file
//	for the named file is returned.  This descriptor MUST	//	for the named file is returned.  This descriptor MUST
//	(presumably by the caller) at some point.		//	(presumably by the caller) at some point.
//								//
//-----------------------------------------------------------	//-----------------------------------------------------------
int							      |	  int
ProcessGetCodeInfo (const char *file, uint32 *startAddr,	ProcessGetCodeInfo (const char *file, uint32 *startAddr,
		    uint32 *codeStart, uint32 *codeSize,      |	    uint32 *codeStart, uint32 *codeSize,
		     uint32 *dataStart, uint32 *dataSize)     |	    uint32 *dataStart, uint32 *dataSize)
{								{
  int		fd;						  int		fd;
  int		totalsize;					  int		totalsize;
  char		buf[100];					  char		buf[100];
  char		*pos;						  char		*pos;

							      >
  // Open the file for reading.  If it returns a negative num	  // Open the file for reading.  If it returns a negative num
  // didn't work.						  // didn't work.
  if ((fd = FsOpen (file, FS_MODE_READ)) < 0) {			  if ((fd = FsOpen (file, FS_MODE_READ)) < 0) {
    dbprintf ('f', "ProcessGetCodeInfo: open of %s failed (%d	    dbprintf ('f', "ProcessGetCodeInfo: open of %s failed (%d
	      file, fd);				      |	        file, fd);
    return (-1);						    return (-1);
  }								  }
  dbprintf ('f', "File descriptor is now %d.\n", fd);		  dbprintf ('f', "File descriptor is now %d.\n", fd);
  if ((totalsize = FsRead (fd, buf, sizeof (buf))) != sizeof 	  if ((totalsize = FsRead (fd, buf, sizeof (buf))) != sizeof 
    dbprintf ('f', "ProcessGetCodeInfo: read got %d (not %d) 	    dbprintf ('f', "ProcessGetCodeInfo: read got %d (not %d) 
	      totalsize, sizeof (buf), file);		      |	        totalsize, sizeof (buf), file);
    FsClose (fd);						    FsClose (fd);
    return (-1);						    return (-1);
  }								  }
  if (dstrstr (buf, "start:") == NULL) {			  if (dstrstr (buf, "start:") == NULL) {
    dbprintf ('f', "ProcessGetCodeInfo: %s missing start line	    dbprintf ('f', "ProcessGetCodeInfo: %s missing start line
    return (-1);						    return (-1);
  }								  }
  pos = (char *)dindex (buf, ':') + 1;				  pos = (char *)dindex (buf, ':') + 1;
  // Get the start address and overall size			  // Get the start address and overall size
  *startAddr = dstrtol (pos, &pos, 16);				  *startAddr = dstrtol (pos, &pos, 16);
  totalsize = dstrtol (pos, &pos, 16);				  totalsize = dstrtol (pos, &pos, 16);
  // Get code & data section start & sizes			  // Get code & data section start & sizes
  *codeStart = dstrtol (pos, &pos, 16);				  *codeStart = dstrtol (pos, &pos, 16);
  *codeSize = dstrtol (pos, &pos, 16);				  *codeSize = dstrtol (pos, &pos, 16);
  *dataStart = dstrtol (pos, &pos, 16);				  *dataStart = dstrtol (pos, &pos, 16);
  *dataSize = dstrtol (pos, &pos, 16);				  *dataSize = dstrtol (pos, &pos, 16);
  // Seek to start of first real line				  // Seek to start of first real line
  FsSeek (fd, 1 + dindex (buf, '\n') - buf, 0);			  FsSeek (fd, 1 + dindex (buf, '\n') - buf, 0);
  return (fd);							  return (fd);
}								}

							      |
							      >
							      >
//-----------------------------------------------------------	//-----------------------------------------------------------
//								//
//	ProcessGetFromFile					//	ProcessGetFromFile
//								//
//	Inputs:							//	Inputs:
//	addr -	points to an integer that contains the addres	//	addr -	points to an integer that contains the addres
//		the byte past that previously returned.  If t	//		the byte past that previously returned.  If t
//		first call to this routine, *addr should be s	//		first call to this routine, *addr should be s
//	fd -	File descriptor from which to read data.  The	//	fd -	File descriptor from which to read data.  The
//		is the same as that used by the DLX simulator	//		is the same as that used by the DLX simulator
//	buf -	points to a buffer that will receive data fro	//	buf -	points to a buffer that will receive data fro
//		file.  Note that the data is NOT 0-terminated	//		file.  Note that the data is NOT 0-terminated
//		include any number of 0 bytes.			//		include any number of 0 bytes.
//	max -	maximum length of data to return.  The routin	//	max -	maximum length of data to return.  The routin
//		until either the address changes or it has re	//		until either the address changes or it has re
//								//
//	Returns the number of bytes actually stored into buf.	//	Returns the number of bytes actually stored into buf.
//	*addr is updated to point to the byte following the l	//	*addr is updated to point to the byte following the l
//	the buffer.						//	the buffer.
//								//
//	Load a file into memory.  The file format consists of	//	Load a file into memory.  The file format consists of
//	leading address, followed by a colon, followed by the	//	leading address, followed by a colon, followed by the
//	to go at that address.  If the address is omitted, th	//	to go at that address.  If the address is omitted, th
//	follows that from the previous line of the file.	//	follows that from the previous line of the file.
//								//
//-----------------------------------------------------------	//-----------------------------------------------------------
int							      |	  int
ProcessGetFromFile (int fd, unsigned char *buf, uint32 *addr,	ProcessGetFromFile (int fd, unsigned char *buf, uint32 *addr,
{								{
  char	localbuf[204];						  char	localbuf[204];
  int	nbytes;							  int	nbytes;
  int	seekpos;						  int	seekpos;
  unsigned char *pos = buf;					  unsigned char *pos = buf;
  char	*lpos = localbuf;					  char	*lpos = localbuf;

							      >
  // Remember our position at the start of the routine so we 	  // Remember our position at the start of the routine so we 
  // it later.							  // it later.
  seekpos = FsSeek (fd, 0, FS_SEEK_CUR);			  seekpos = FsSeek (fd, 0, FS_SEEK_CUR);
  // The maximum number of characters we could read is limite	  // The maximum number of characters we could read is limite
  // maximum buffer space available to the caller * 2 because	  // maximum buffer space available to the caller * 2 because
  // characters in the input file result in a single byte of 	  // characters in the input file result in a single byte of 
  // info being read in.					  // info being read in.
  max = max * 2;						  max = max * 2;
  // If the callers maximum is greater than the available buf	  // If the callers maximum is greater than the available buf
  // limit the buffer space further.				  // limit the buffer space further.
  if (max > (sizeof(localbuf)-4)) {				  if (max > (sizeof(localbuf)-4)) {
    max = sizeof(localbuf)-4;					    max = sizeof(localbuf)-4;
  }								  }
  if ((nbytes = FsRead (fd, localbuf, max)) <= 0) {		  if ((nbytes = FsRead (fd, localbuf, max)) <= 0) {
    return (0);							    return (0);
  }								  }
  // 'Z' is unused in load file, so use it to mark the end of	  // 'Z' is unused in load file, so use it to mark the end of
  // Back up until just after the last newline in the data we	  // Back up until just after the last newline in the data we
  dbprintf ('f', "Got %d bytes at offset %d ...", nbytes, see	  dbprintf ('f', "Got %d bytes at offset %d ...", nbytes, see
  while (localbuf[--nbytes] != '\n') {				  while (localbuf[--nbytes] != '\n') {
  }								  }
  localbuf[nbytes+1] = 'Z';					  localbuf[nbytes+1] = 'Z';
  localbuf[nbytes+2] = '\0';					  localbuf[nbytes+2] = '\0';
  dbprintf ('f', " terminated at %d.\n", nbytes);		  dbprintf ('f', " terminated at %d.\n", nbytes);
  dbprintf ('f', "Buffer is '%s'\n", localbuf);			  dbprintf ('f', "Buffer is '%s'\n", localbuf);
  nbytes = 0;							  nbytes = 0;
  while (dindex (lpos, 'Z') != NULL) {				  while (dindex (lpos, 'Z') != NULL) {
    if (dindex (lpos, ':') == NULL) {				    if (dindex (lpos, ':') == NULL) {
      break;							      break;
    }								    }
    if (*lpos != ':') {						    if (*lpos != ':') {
      // If we're going to go to a new address, we break out 	      // If we're going to go to a new address, we break out 
      // loop and return what we've got already.		      // loop and return what we've got already.
      if (nbytes > 0) {						      if (nbytes > 0) {
	break;						      |	        break;
      }								      }
      *addr = dstrtol (lpos, &lpos, 16);			      *addr = dstrtol (lpos, &lpos, 16);
      dbprintf ('f', "New address is 0x%x.\n", *addr);		      dbprintf ('f', "New address is 0x%x.\n", *addr);
    }								    }
    if (*lpos != ':') {						    if (*lpos != ':') {
      break;							      break;
    }								    }
    lpos++;	// skip past colon				    lpos++;	// skip past colon
    while (1) {							    while (1) {
      while (((*lpos) == ' ') || (*lpos == '\t')) {		      while (((*lpos) == ' ') || (*lpos == '\t')) {
	lpos++;						      |	        lpos++;
      }								      }
      if (*lpos == '\n') {					      if (*lpos == '\n') {
	lpos++;						      |	        lpos++;
	break;						      |	        break;
      } else if (!(isxdigit (*lpos) && isxdigit (*(lpos+1))))	      } else if (!(isxdigit (*lpos) && isxdigit (*(lpos+1))))
     // Exit loop if at least one digit isn't a hex digit.    |	        // Exit loop if at least one digit isn't a hex digit.
	break;						      |	        break;
      }								      }
      pos[nbytes++] = (getxvalue(*lpos) * 16) + getxvalue(*(l	      pos[nbytes++] = (getxvalue(*lpos) * 16) + getxvalue(*(l
      lpos += 2;						      lpos += 2;
      (*addr)++;						      (*addr)++;
    }								    }
  }								  }
  // Seek to just past the last line we read.			  // Seek to just past the last line we read.
  FsSeek (fd, seekpos + lpos - localbuf, FS_SEEK_SET);		  FsSeek (fd, seekpos + lpos - localbuf, FS_SEEK_SET);
  dbprintf ('f', "Seeking to %d and returning %d bytes!\n",	  dbprintf ('f', "Seeking to %d and returning %d bytes!\n",
	    seekpos + lpos - localbuf, nbytes);		      |	      seekpos + lpos - localbuf, nbytes);
  return (nbytes);						  return (nbytes);
}								}
							      |
							      >
							      >
							      >
//-----------------------------------------------------------	//-----------------------------------------------------------
//								//
//	main							//	main
//								//
//	This routine is called when the OS starts up.  It all	//	This routine is called when the OS starts up.  It all
//	PCB for the first process - the one corresponding to 	//	PCB for the first process - the one corresponding to 
//	thread of execution.  Note that the stack pointer is 	//	thread of execution.  Note that the stack pointer is 
//	set correctly by _osinit (assembly language code) to 	//	set correctly by _osinit (assembly language code) to 
//	to the stack for the 0th process.  This stack isn't v	//	to the stack for the 0th process.  This stack isn't v
//	though, so it should be replaced by the system stack 	//	though, so it should be replaced by the system stack 
//	currently running process.				//	currently running process.
//								//
//-----------------------------------------------------------	//-----------------------------------------------------------
main (int argc, char *argv[])					main (int argc, char *argv[])
{								{
  int		i, j;						  int		i, j;
  int		n;						  int		n;
  char	buf[120];						  char	buf[120];
  char		*userprog = (char *)0;				  char		*userprog = (char *)0;
  static PCB	temppcb;					  static PCB	temppcb;
  uint32	addr;						  uint32	addr;
  extern void	SysprocCreateProcesses ();			  extern void	SysprocCreateProcesses ();
  char *param[12]={NULL, NULL, NULL, NULL, NULL, NULL, NULL, 	  char *param[12]={NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
  	 	   NULL, NULL, NULL, NULL};		      |	    NULL, NULL, NULL, NULL};
  int base;							  int base;

  debugstr[0] = '\0';					      |
							      >	  //  debugstr[0] = 'p';
							      >	  debugstr[4] = '\0';
  MyFuncRetZero();						  MyFuncRetZero();
  printf ("Got %d arguments.\n", argc);				  printf ("Got %d arguments.\n", argc);
  printf ("Available memory: 0x%x -> 0x%x.\n", lastosaddress,	  printf ("Available memory: 0x%x -> 0x%x.\n", lastosaddress,
	  MemoryGetSize ());				      |	      MemoryGetSize ());
  printf ("Argument count is %d.\n", argc);			  printf ("Argument count is %d.\n", argc);
  for (i = 0; i < argc; i++) {					  for (i = 0; i < argc; i++) {
    printf ("Argument %d is %s.\n", i, argv[i]);		    printf ("Argument %d is %s.\n", i, argv[i]);
  }								  }
//  *((int *)0xfff00100) = 't';				      |	  //  *((int *)0xfff00100) = 't';
  FsModuleInit ();						  FsModuleInit ();
  for (i = 0; i < argc; i++)					  for (i = 0; i < argc; i++)
  {								  {
    if (argv[i][0] == '-')					    if (argv[i][0] == '-')
    {								    {
      switch (argv[i][1])					      switch (argv[i][1])
      {								      {
      case 'D':						      |	        case 'D':
	dstrcpy (debugstr, argv[++i]);			      |	          dstrcpy (debugstr, argv[++i]);
	break;						      |	          break;
      case 'i':						      |	        case 'i':
	n = dstrtol (argv[++i], (void *)0, 0);		      |	          n = dstrtol (argv[++i], (void *)0, 0);
	ditoa (n, buf);					      |	          ditoa (n, buf);
	printf ("Converted %s to %d=%s\n", argv[i], n, buf);  |	          printf ("Converted %s to %d=%s\n", argv[i], n, buf)
	break;						      |	          break;
      case 'f':						      |	        case 'f':
      {							      |	          {
	int	start, codeS, codeL, dataS, dataL, fd, j;     |	            int	start, codeS, codeL, dataS, dataL, fd, j;
	int	addr = 0;				      |	            int	addr = 0;
	static unsigned char buf[200];			      |	            static unsigned char buf[200];
	fd = ProcessGetCodeInfo (argv[++i], &start, &codeS, & |	            fd = ProcessGetCodeInfo (argv[++i], &start, &code
				 &dataL);		      |	                &dataL);
	printf ("File %s -> start=0x%08x\n", argv[i], start); |	            printf ("File %s -> start=0x%08x\n", argv[i], sta
	printf ("File %s -> code @ 0x%08x (size=0x%08x)\n", a |	            printf ("File %s -> code @ 0x%08x (size=0x%08x)\n
		codeL);					      |	                codeL);
	printf ("File %s -> data @ 0x%08x (size=0x%08x)\n", a |	            printf ("File %s -> data @ 0x%08x (size=0x%08x)\n
		dataL);					      |	                dataL);
	while ((n = ProcessGetFromFile (fd, buf, &addr, sizeo |	            while ((n = ProcessGetFromFile (fd, buf, &addr, s
	{						      |	            {
	  for (j = 0; j < n; j += 4)			      |	              for (j = 0; j < n; j += 4)
	  {						      |	              {
	    printf ("%08x: %02x%02x%02x%02x\n", addr + j - n, |	                printf ("%08x: %02x%02x%02x%02x\n", addr + j 
		    buf[j+2], buf[j+3]);		      |	                    buf[j+2], buf[j+3]);
	  }						      |	              }
	}						      |	            }
	close (fd);					      |	            close (fd);
	break;						      |	            break;
      }							      |	          }
      case 'u':						      |	        case 'u':
	userprog = argv[++i];				      |	          userprog = argv[++i];
        base = i;					      |	          base = i;
	break;						      |	          break;
      default:						      |	        default:
	printf ("Option %s not recognized.\n", argv[i]);      |	          printf ("Option %s not recognized.\n", argv[i]);
	break;						      |	          break;
      }								      }
      if(userprog)						      if(userprog)
        break;							        break;
    }								    }
  }								  }
  dbprintf ('i', "About to initialize queues.\n");		  dbprintf ('i', "About to initialize queues.\n");
  QueueModuleInit ();						  QueueModuleInit ();
  dbprintf ('i', "After initializing queues.\n");		  dbprintf ('i', "After initializing queues.\n");
  MemoryModuleInit ();						  MemoryModuleInit ();
  dbprintf ('i', "After initializing memory.\n");		  dbprintf ('i', "After initializing memory.\n");

							      >
  ProcessModuleInit ();						  ProcessModuleInit ();
  dbprintf ('i', "After initializing processes.\n");		  dbprintf ('i', "After initializing processes.\n");
  ShareModuleInit ();						  ShareModuleInit ();
  dbprintf ('i', "After initializing shared memory.\n");	  dbprintf ('i', "After initializing shared memory.\n");
  SynchModuleInit ();						  SynchModuleInit ();
  dbprintf ('i', "After initializing synchronization tools.\n	  dbprintf ('i', "After initializing synchronization tools.\n
  KbdModuleInit ();						  KbdModuleInit ();
  dbprintf ('i', "After initializing keyboard.\n");		  dbprintf ('i', "After initializing keyboard.\n");
  for (i = 0; i < 100; i++) {					  for (i = 0; i < 100; i++) {
    buf[i] = 'a';						    buf[i] = 'a';
  }								  }
  i = FsOpen ("vm", FS_MODE_WRITE);				  i = FsOpen ("vm", FS_MODE_WRITE);
  dbprintf ('i', "VM Descriptor is %d\n", i);			  dbprintf ('i', "VM Descriptor is %d\n", i);
  FsSeek (i, 0, FS_SEEK_SET);					  FsSeek (i, 0, FS_SEEK_SET);
  FsWrite (i, buf, 80);						  FsWrite (i, buf, 80);
  FsClose (i);							  FsClose (i);
  if (userprog != (char *)0) {					  if (userprog != (char *)0) {
      for(i=base;i<argc&&i-base<11; i++)		      |	    for(i=base;i<argc&&i-base<11; i++)
      {							      |	    {
        param[i-base] = argv[i];			      |	      param[i-base] = argv[i];
      }							      |	    }
      process_create(0,0,param[0], param[1], param[2], param[ |	    process_create(0,0,param[0], param[1], param[2], param[3]
      		     param[5], param[6], param[7], param[8],  |	        param[5], param[6], param[7], param[8], param[9],
		     param[10], param[11]);		      |	        param[10], param[11]);
//    ProcessFork (0, (uint32)"Help Me man!", userprog, 1);   |	    //    ProcessFork (0, (uint32)"Help Me man!", userprog, 1
  }								  }
							      >
							      >
  SysprocCreateProcesses ();					  SysprocCreateProcesses ();
  dbprintf ('i', "Created processes - about to set timer quan	  dbprintf ('i', "Created processes - about to set timer quan
  TimerSet (processQuantum);					  TimerSet (processQuantum);
  dbprintf ('i', "Set timer quantum to %d, about to run first	  dbprintf ('i', "Set timer quantum to %d, about to run first
	    processQuantum);				      |	      processQuantum);
  intrreturn ();						  intrreturn ();
  // Should never be called because the scheduler exits when 	  // Should never be called because the scheduler exits when 
  // are no runnable processes left.				  // are no runnable processes left.
  exitsim();	// NEVER RETURNS!				  exitsim();	// NEVER RETURNS!
}								}

							      >
float MyFuncRetZero()						float MyFuncRetZero()
{								{
  return 0;							  return 0;
}								}

							      >
unsigned GetCurrentPid()					unsigned GetCurrentPid()
{								{
  return (unsigned)(currentPCB - pcbs);				  return (unsigned)(currentPCB - pcbs);
}								}

							      >
unsigned findpid(PCB *pcb)					unsigned findpid(PCB *pcb)
{								{
  return (unsigned)(pcb - pcbs);				  return (unsigned)(pcb - pcbs);
}								}

							      >
void process_create(int p_nice, int p_info, char *name, ...)	void process_create(int p_nice, int p_info, char *name, ...)
{								{
  char **args;							  char **args;
  int i, j, k;							  int i, j, k;
  char allargs[1000];						  char allargs[1000];
  args = &name;							  args = &name;

							      >
  k=0;								  k=0;
  for(i=0; args[i]!=NULL; i++)					  for(i=0; args[i]!=NULL; i++)
  {								  {
    j=0;							    j=0;
    do {							    do {
      allargs[k] = args[i][j];					      allargs[k] = args[i][j];
      j++; k++;							      j++; k++;
    } while(args[i][j-1]!='\0');				    } while(args[i][j-1]!='\0');
  }								  }
  allargs[k] = allargs[k+1] = 0;				  allargs[k] = allargs[k+1] = 0;
  ProcessFork(0, (uint32)allargs, p_nice,p_info,name, 1);	  ProcessFork(0, (uint32)allargs, p_nice,p_info,name, 1);
}								}
							      >
